import os
from pathlib import Path
from dataclasses import dataclass, field
import json

from dataclasses_json import dataclass_json

import custom_logger
from decode import Decoder
import custom_request
from output_file import OutputFiles

CURRENT_DIR = Path(__file__).resolve().parent
logger = custom_logger.create_logger('NOVEL SCRAPPING')

@dataclass_json
@dataclass
class Metadata:
    novel_title : str
    author : str = "Anonymous"
    start_year: int = None
    end_year: int = None
    language: str = "en"

@dataclass_json
@dataclass
class Chapter:
    chapter_title: str
    chapter_link: str
    def __init__(self,
                 chapter_title: str,
                 content: str,
                 chapter_link: str = None,
                 html: bool = False):
        self.chapter_title = chapter_title
        self.content = content
        self.chapter_link = chapter_link
        self.html = html

    def __str__(self):
        return f'Title: {self.chapter_title}, link: {self.chapter_link}'

    def __lt__(self, another):
        return self.chapter_title < another.chapter_title

class Volume:
    def __init__(self, metadata: Metadata,
                 volume_title: str = None,
                 image_path: str = f'{CURRENT_DIR}/cover.jpg',
                 single_volume: bool = False,
                 autogenerated_title: bool = False):

        self.metadata = metadata
        self.volume_title = volume_title
        self.chapters: list[Chapter] = []
        self.image_path = image_path
        self.single_volume = single_volume
        self.autogenerated_title: bool = autogenerated_title

    def create_chapter(self,
                       chapter_title: str,
                       content: str,
                       chapter_link: str = None,
                       html: bool = False):
        if not chapter_idx:
            chapter_idx = 1 if len(self.chapters) < 1 else len(self.chapters)

        chapter = Chapter(chapter_title, content, chapter_link, html)
        self.insert_chapter(chapter, chapter_idx)

    def insert_chapter(self, new_chapter: Chapter, chapter_idx: int):
        for chapter in self.chapters[chapter_idx:]:
            chapter.chapter_idx += 1
        self.chapters.insert(chapter_idx, new_chapter)

    # Sort by volume_idx
    def __lt__(self, another):
        return self.volume_title < another.volume_title

@dataclass_json
@dataclass
class Novel:
    metadata: Metadata
    chapters: list[Chapter] = field(default_factory=list)
    toc_main_link: str = None
    toc_link_list: list[str] = field(default_factory=list)
    # toc: list[dict] = []
    # output_files: OutputFiles = None

    def __init__(self,
                 novel_title: str = None,
                 author: str = "Anonymous",
                 start_year: int = None,
                 end_year: int = None,
                 language: str = "en",
                 toc_main_link: str = None,
                 toc_link_list: list[str] = None,
                 metadata: Metadata = None,
                 chapters: list[Chapter] = None):

        if metadata is not None:
            self.metadata = metadata
        elif novel_title is not None:
            self.metadata = Metadata(novel_title,
                                    author=author,
                                    start_year=start_year,
                                    end_year=end_year,
                                    language=language)
        else:
            raise ValueError("You need to set 'novel_title' or 'metadata'.")

        self.chapters = chapters if chapters else []

        self.toc_main_link = toc_main_link
        self.toc_link_list = toc_link_list if toc_link_list else []

        self.toc = [{}]
        self.output_files = OutputFiles(self.metadata.novel_title)
        self.output_files.save_novel_json(self.to_json())
        
    def add_chapter_toc(self,
                    chapter_link: str,
                    chapter_idx: int = None):
        print('test')

    def set_toc_main_link(self, toc_main_link: str):
        self.toc_main_link = toc_main_link
        self.update_chapter_list(update_toc=True)

    def update_chapter_list(self, update_toc: bool = False):
        host = self._obtain_host(self.toc_main_link)
        decoder = Decoder(host)

        toc_content = get_url_or_temp_file(self.output_files,
                                           self.toc_main_link,
                                           'toc_0.html',
                                           reload=update_toc)

        if not toc_content:
            logger.warning(f'No content found on link {self.toc_main_link}')
            return

        toc_links = [self.toc_main_link]
        if decoder.has_pagination():
            next_link_tag = decoder.decode_html(toc_content, 'next_page')
            aux = 1

            while next_link_tag:
                next_link = next_link_tag[0]['href']

                toc_new_content = get_url_or_temp_file(self.output_files,
                                                       next_link,
                                                       f'toc_{aux}.html',
                                                       reload=update_toc)
                if toc_new_content:
                    toc_links.append(next_link)
                    next_link_tag = decoder.decode_html(toc_new_content, 'next_page')
                aux += 1
        links = []
        for aux, link in enumerate(toc_links):
            toc_content = get_url_or_temp_file(self.output_files, link, f'toc_{aux}.html')
            toc_links = decoder.decode_html(toc_content, 'index')
            toc_links = [link['href'] for link in toc_links]
            if toc_links:
                links = [*links, *toc_links]
        self.toc_link_list = links

    def _obtain_host(self, url: str):
        try:
            host = url.split(':')[1]
        except Exception:
            pass
        while host.startswith('/'):
            host = host[1:]

        host = host.split('/')[0].replace('www.', '')

        return host
    
    # def to_dict(self):
    #     return {
    #         'metadata': asdict(self.metadata),
    #         # 'chapters': [asdict(chapter) for chapter in self.chapters],
    #         'toc_main_link': self.toc_main_link,
    #         'toc_link_list': self.toc_link_list,
    #         'toc': self.toc,
    #     }
        
    # def to_json(self):
    #     return json.dumps(self.to_dict(), ensure_ascii=False, indent=4)
    
    # def create_volume(self,
    #                   volume_idx: int = None,
    #                   volume_title: str = None,
    #                   image_path: str = None):
    #     if self.single_volume and volume_idx > 1:
    #         logger.error(f'Tried to create more than one volume for {self.metadata.novel_title}')
    #         return

    #     if not volume_idx:
    #         # If no index, use latest
    #         volume_idx = len(self.volumes)
    #     autogenerated_title = False
    #     if not volume_title:
    #         # Autogenerate Volume title:
    #         autogenerated_title = True
    #         if self.single_volume:
    #             volume_title = self.metadata.novel_title
    #         else:
    #             aux_idx = 1
    #             for volume in self.volumes[:volume_idx]:
    #                 if volume.autogenerated_title:
    #                     aux_idx += 1
    #             volume_title = f'{self.metadata.novel_title} {create_volume_id(aux_idx)}'

    #     volume = Volume(self.metadata, volume_title, image_path, self.single_volume, autogenerated_title)
    #     self.insert_volume(volume, volume_idx)

    # def insert_volume(self, new_volume: Volume, volume_idx: int):
    #     self.volumes.insert(volume_idx, new_volume)

def create_volume_id(n: int):
    return f'v{n:02}'

def get_url_or_temp_file(output_file: OutputFiles,
                         url: str,
                         temp_file_path: str = None,
                         reload: bool = False):
    if temp_file_path and not reload:
        content = output_file.load_from_temp_file(temp_file_path)
        if content:
             return content

    content = custom_request.get_html_content(url)
    if not content:
        return

    if temp_file_path:
        output_file.save_to_temp_file(temp_file_path, content)
    return content