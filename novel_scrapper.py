import os
from pathlib import Path

import custom_logger
import temp_output_file
from decode import Decoder
import custom_request

CURRENT_DIR = Path(__file__).resolve().parent
logger = custom_logger.create_logger('NOVEL SCRAPPING')

class Metadata:
    def __init__(self,
                 novel_title: str,
                 author: str = "Anonymous",
                 start_year: int = None,
                 end_year: int = None,
                 language: str = "en"):
        self.novel_title = novel_title
        self.author = author
        self.start_year = start_year
        self.end_year = end_year
        self.language = language

class Chapter:
    def __init__(self,
                 chapter_title: str,
                 content: str,
                 chapter_link: str = None,
                 html: bool = False):
        self.chapter_title = chapter_title
        self.content = content
        self.chapter_link = chapter_link
        self.html = html

    def __str__(self):
        return f'Title: {self.chapter_title}, link: {self.chapter_link}'

    def __lt__(self, another):
        return self.chapter_title < another.chapter_title

class Volume:
    def __init__(self, metadata: Metadata,
                 volume_title: str = None,
                 image_path: str = f'{CURRENT_DIR}/cover.jpg',
                 single_volume: bool = False,
                 autogenerated_title: bool = False):

        self.metadata = metadata
        self.volume_title = volume_title
        self.chapters: list[Chapter] = []
        self.image_path = image_path
        self.single_volume = single_volume
        self.autogenerated_title: bool = autogenerated_title

    def create_chapter(self,
                       chapter_title: str,
                       content: str,
                       chapter_link: str = None,
                       html: bool = False):
        if not chapter_idx:
            chapter_idx = 1 if len(self.chapters) < 1 else len(self.chapters)

        chapter = Chapter(chapter_title, content, chapter_link, html)
        self.insert_chapter(chapter, chapter_idx)

    def insert_chapter(self, new_chapter: Chapter, chapter_idx: int):
        for chapter in self.chapters[chapter_idx:]:
            chapter.chapter_idx += 1
        self.chapters.insert(chapter_idx, new_chapter)

    # Sort by volume_idx
    def __lt__(self, another):
        return self.volume_title < another.volume_title

class Novel:
    def __init__(self,
                 novel_title: str,
                 author: str = "Anonymous",
                 start_year: int = None,
                 end_year: int = None,
                 language: str = "en",
                 toc_main_link: str = None,
                 single_volume: bool = False):

        self.metadata = Metadata(novel_title,
                                 author=author,
                                 start_year=start_year,
                                 end_year=end_year,
                                 language=language)
        self.volumes: list[Volume] = []
        self.toc_main_link = toc_main_link
        self.toc_link_list: list[str] = []
        self.single_volume = single_volume
        self.toc = [{}]
        self.novel_temp_dir = f'{novel_title}'

    def create_volume(self,
                      volume_idx: int = None,
                      volume_title: str = None,
                      image_path: str = None):
        if self.single_volume and volume_idx > 1:
            logger.error(f'Tried to create more than one volume for {self.metadata.novel_title}')
            return

        if not volume_idx:
            # If no index, use latest
            volume_idx = len(self.volumes)
        autogenerated_title = False
        if not volume_title:
            # Autogenerate Volume title:
            autogenerated_title = True
            if self.single_volume:
                volume_title = self.metadata.novel_title
            else:
                aux_idx = 1
                for volume in self.volumes[:volume_idx]:
                    if volume.autogenerated_title:
                        aux_idx += 1
                volume_title = f'{self.metadata.novel_title} {create_volume_id(aux_idx)}'

        volume = Volume(self.metadata, volume_title, image_path, self.single_volume, autogenerated_title)
        self.insert_volume(volume, volume_idx)

    def insert_volume(self, new_volume: Volume, volume_idx: int):
        self.volumes.insert(volume_idx, new_volume)

    def update_toc(self, toc_main_link: str = None):
        if toc_main_link:
            self.toc_main_link = toc_main_link

        if not self.toc_main_link:
            logger.warning(f'No TOC link for novel {self.metadata.novel_title}')
            return

        host = self._obtain_host(self.toc_main_link)
        decoder = Decoder(host)

        toc_content = get_url_or_temp_file(self.toc_main_link, f'{self.novel_temp_dir}/toc_0.html')
        if not toc_content:
            logger.warning(f'No content found on link {self.toc_main_link}')
            return

        toc_links = [toc_main_link]
        if decoder.has_pagination():
            next_link_tag = decoder.decode_html(toc_content, 'next_page')
            aux = 1
            while next_link_tag:
                next_link = next_link_tag[0]['href']
                toc_new_content = get_url_or_temp_file(next_link, f'{self.novel_temp_dir}/toc_{aux}.html')
                if toc_new_content:
                    toc_links.append(next_link)
                    next_link_tag = decoder.decode_html(toc_new_content, 'next_page')
                aux += 1

        links = []
        for aux, link in enumerate(toc_links):
            toc_content = get_url_or_temp_file(link, f'{self.novel_temp_dir}/toc_{aux}.html')
            toc_links = decoder.decode_html(toc_content, 'index')
            toc_links = [link['href'] for link in toc_links]
            if toc_links:
                links = [*links, *toc_links]
        self.toc_link_list = links

    def _obtain_host(self, url: str):
        try:
            host = url.split(':')[1]
        except Exception:
            pass
        while host.startswith('/'):
            host = host[1:]

        host = host.split('/')[0].replace('www.', '')

        return host

def create_volume_id(n: int):
    return f'v{n:02}'

def get_url_or_temp_file(url: str, temp_file_path: str = None):
    if temp_file_path:
        content = temp_output_file.load_from_temp_file(temp_file_path)
        if content:
             return content

    content = custom_request.get_html_content(url)
    if not content:
        return

    if temp_file_path:
        temp_output_file.save_to_temp_file(temp_file_path, content)
    return content