import os
from pathlib import Path
from dataclasses import dataclass, field
import json

from dataclasses_json import dataclass_json
from ebooklib import epub

import custom_logger
from decode import Decoder
import custom_request
from output_file import OutputFiles
import utils

CURRENT_DIR = Path(__file__).resolve().parent
logger = custom_logger.create_logger('NOVEL SCRAPPING')

@dataclass_json
@dataclass
class Metadata:
    novel_title : str
    author : str = "Anonymous"
    start_year: int = None
    end_year: int = None
    language: str = "en",
    description: str = None,
    cover_image_path: str = None

@dataclass_json
@dataclass
class Chapter:
    chapter_link: str
    chapter_html_filename: str
    chapter_title: str = None

    def __str__(self):
        return f'Title: {self.chapter_title}, link: {self.chapter_link}'

    def __lt__(self, another):
        return self.chapter_title < another.chapter_title

# class Volume:
#     def __init__(self, metadata: Metadata,
#                  volume_title: str = None,
#                  image_path: str = f'{CURRENT_DIR}/cover.jpg',
#                  single_volume: bool = False,
#                  autogenerated_title: bool = False):

#         self.metadata = metadata
#         self.volume_title = volume_title
#         self.chapters: list[Chapter] = []
#         self.image_path = image_path
#         self.single_volume = single_volume
#         self.autogenerated_title: bool = autogenerated_title

#     def create_chapter(self,
#                        chapter_title: str,
#                        content: str,
#                        chapter_link: str = None,
#                        html: bool = False):
#         if not chapter_idx:
#             chapter_idx = 1 if len(self.chapters) < 1 else len(self.chapters)

#         chapter = Chapter(chapter_title, content, chapter_link, html)
#         self.insert_chapter(chapter, chapter_idx)

#     def insert_chapter(self, new_chapter: Chapter, chapter_idx: int):
#         for chapter in self.chapters[chapter_idx:]:
#             chapter.chapter_idx += 1
#         self.chapters.insert(chapter_idx, new_chapter)

#     # Sort by volume_idx
#     def __lt__(self, another):
#         return self.volume_title < another.volume_title

@dataclass_json
@dataclass
class Novel:
    metadata: Metadata
    chapters: list[Chapter] = field(default_factory=list)
    toc_main_link: str = None
    toc_links_list: list[str] = field(default_factory=list)
    # toc: list[dict] = []
    # output_files: OutputFiles = None

    def __init__(self,
                 novel_title: str = None,
                 toc_main_link: str = None,
                 toc_links_list: list[str] = None,
                 metadata: Metadata = None,
                 chapters: list[Chapter] = None):

        if metadata is not None:
            self.metadata = metadata
        elif novel_title is not None:
            self.metadata = Metadata(novel_title)
        else:
            raise ValueError("You need to set 'novel_title' or 'metadata'.")

        self.chapters = chapters if chapters else []

        self.toc_main_link = toc_main_link
        self.toc_links_list = toc_links_list if toc_links_list else []

        self.toc = [{}]
        self.output_files = OutputFiles(self.metadata.novel_title)
        self.save_novel_to_json()
        self.decoder = Decoder(utils.obtain_host(self.toc_main_link))
        
    def set_metadata(self, author: str = None,
                 start_year: int = None,
                 end_year: int = None,
                 language: str = "en",
                 description: str = None):
        self.metadata.author = author
        self.metadata.start_year = start_year
        self.metadata.end_year = end_year
        self.metadata.language = language
        self.metadata.description = description
        self.save_novel_to_json()
    
    def set_cover_image(self, cover_image_path: str):
        new_cover_image_path = self.output_files.save_cover_img(cover_image_path)
        if new_cover_image_path:
            self.metadata.cover_image_path = new_cover_image_path
            self.save_novel_to_json()
            logger.info(f'New cover image on file {self.metadata.cover_image_path}')
        
    def save_novel_to_json(self):
        self.output_files.save_novel_json(self.to_dict())

    def set_toc_main_link(self, toc_main_link: str):
        self.toc_main_link = toc_main_link
        self.update_chapter_list(update_toc=True)

    def update_chapter_list(self, update_toc: bool = False):
        toc_content, _ = utils.get_url_or_temp_file(self.output_files,
                                           self.toc_main_link,
                                           'toc_0.html',
                                           reload=update_toc)

        if not toc_content:
            logger.warning(f'No content found on link {self.toc_main_link}')
            return

        toc_links = [self.toc_main_link]
        if self.decoder.has_pagination():
            next_link_tag = self.decoder.decode_html(toc_content, 'next_page')
            aux = 1

            while next_link_tag:
                next_link = next_link_tag[0]['href']

                toc_new_content, _ = utils.get_url_or_temp_file(self.output_files,
                                                       next_link,
                                                       f'toc_{aux}.html',
                                                       reload=update_toc)
                if toc_new_content:
                    toc_links.append(next_link)
                    next_link_tag = self.decoder.decode_html(toc_new_content, 'next_page')
                aux += 1
        links = []
        for aux, link in enumerate(toc_links):
            toc_content, _ = utils.get_url_or_temp_file(self.output_files, link, f'toc_{aux}.html')
            toc_links = self.decoder.decode_html(toc_content, 'index')
            toc_links = [link['href'] for link in toc_links]
            if toc_links:
                links = [*links, *toc_links]
        self.toc_links_list = links
    
    def scrap_chapter(self, chapter_link: str, file_path: str = None, update_html: bool = False):
        chapter_content, chapter_html_filename = utils.get_url_or_temp_file(self.output_files,
                                               chapter_link,
                                               file_path,
                                               update_html)
        if chapter_content and chapter_html_filename:
            chapter_title = self.decoder.decode_html(chapter_content,
                                                     'title')
            if not chapter_title:
                logger.warning(f'No chapter title found for link: "{chapter_link}" on path: "{file_path}", using decoder: "title"')
                chapter_title = f'{self.metadata.novel_title} Chapter'

            chapter = Chapter(chapter_title=chapter_title,
                              chapter_link=chapter_link,
                              chapter_html_filename=chapter_html_filename)
            logger.info(f'Chapter scrapped from link: {chapter_link}')

            return chapter
        logger.warning(f'Failed to create chapter on link: "{chapter_link}" on path "{chapter_html_filename}"')
        
    def scrap_all_chapters(self, update_toc: bool = False, update_chapters: bool = False):
        self.update_chapter_list(update_toc)
        
        if self.toc_links_list:
            for link_idx, chapter_link in enumerate(self.toc_links_list):
                chapter = self.scrap_chapter(chapter_link,
                                             update_html=update_chapters)
                if chapter:
                    # Search if the chapter exists
                    chapter_idx = self.find_chapter_index_by_link(chapter_link)
                    if chapter_idx is not None:
                        # Replace the existing chapter
                        self.chapters[chapter_idx] = chapter
                        if chapter_idx != link_idx:
                            chapter_to_move = self.chapters.pop(chapter_idx)
                            self.chapters.insert(link_idx, chapter_to_move)
                    else:
                        # Add the new chapter
                        self.chapters.insert(link_idx, chapter)
                    self.save_novel_to_json()
        else:
            logger.warning('No links found on toc_links_list')

    def find_chapter_index_by_link(self, chapter_link: str):
        for index, chapter in enumerate(self.chapters):
            if chapter.chapter_link == chapter_link:
                return index
        return None

    def create_epub_book(self, book_title: str = None):
        book = epub.EpubBook()
        if not book_title:
            book_title = self.metadata.novel_title
        book.set_title(book_title)
        # book.set_language(self.metadata.language)
        # book.add_metadata('DC', 'description', self.metadata.description)
        book.add_metadata('DC', 'subject', 'Novela Web')
        book.add_metadata('DC', 'subject', 'Scrapped')

        if self.metadata.author:
            book.add_author(self.metadata.author)
        # book.add_metadata(None, 'start_year', self.metadata.start_year)
        # book.add_metadata(None, 'end_year', self.metadata.end_year)

        # Testing with Calibre
        # if collection:
        #     book.add_metadata('OPF', 'meta', collection['num'], {'refines': 'id-3', 'property': 'group-position'})
        #     book.add_metadata('OPF', 'meta', 'series', {'refines': 'id-3', 'property': 'collection-type'})
        #     book.add_metadata('OPF', 'meta', 'test', {'id': 'id-3', 'property': 'belongs-to-collection'})

        # if self.metadata.cover_image_path:
        #     cover_image_content = self.output_files.load_cover_img(self.metadata.cover_image_path)
        #     if cover_image_content:
        #         book.set_cover('cover.jpg', cover_image_content)
        #         book.spine += ['cover']
        book.spine.append('nav')
        return book

    def get_chapter_content(self, chapter: Chapter = None, idx: int = None):
        if idx:
            try:
                chapter = self.chapters[idx]
            except IndexError:
                logger.error(f'Chapter index {idx} not found')
                return
        if chapter:
            chapter_html, _ = utils.get_url_or_temp_file(self.output_files,
                                                        chapter.chapter_link,
                                                        chapter.chapter_html_filename)
            paragraphs = self.decoder.decode_html(chapter_html, 'content')
            title = chapter.chapter_title
            if not title:
                title = f'{self.metadata.novel_title} Chapter {self.find_chapter_index_by_link(chapter.chapter_link) + 1}'
            chapter_content = f'<h4>{title}</h4>'
            if paragraphs:
                logger.info(f'{len(paragraphs)} paragraphs found in chapter link {chapter.chapter_link}')
                for paragraph in paragraphs:
                    chapter_content += str(paragraph)
                return title, chapter_content
            logger.warning(f'No chapter content found for chapter link {chapter.chapter_link} on file {chapter.chapter_html_filename}')

        logger.warning('No chapter given')

    def save_chapters_to_epub(self, chapters_start: int, chapters_num: int = 100, chapters_end: int = None):
        if chapters_start >= len(self.chapters):
            logger.warning(f'start_chapter out of range')
            return

        if not chapters_end:
            chapters_end = chapters_start + chapters_num
        
        book_title = f'{self.metadata.novel_title} Chapters {chapters_start + 1} - {chapters_end}'
        book = self.create_epub_book(book_title)

        for chapter in self.chapters[chapters_start:chapters_end]:
            title, chapter_content = self.get_chapter_content(chapter)
            if not chapter_content:
                logger.warning(f'Error reading chapter')
                continue

            file_name = utils.generate_epub_file_name_from_title(title)

            chapter_epub = epub.EpubHtml(title=title, file_name=file_name)
            chapter_epub.set_content(chapter_content)
            book.add_item(chapter_epub)
            link = epub.Link(file_name, title, file_name.rstrip('.xhtml'))
            toc = book.toc
            toc.append(link)
            book.toc = toc
            book.spine.append(chapter_epub)

        book.add_item(epub.EpubNcx())
        book.add_item(epub.EpubNav())
        output_epub_filepath = f'{self.output_files.get_output_dir()}/{book_title}.epub'
        epub.write_epub(output_epub_filepath, book)
        logger.info(f'Saved epub to file {output_epub_filepath}')
