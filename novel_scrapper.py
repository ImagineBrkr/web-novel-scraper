import os
from pathlib import Path
from dataclasses import dataclass, field
import json

from dataclasses_json import dataclass_json

import custom_logger
from decode import Decoder
import custom_request
from output_file import OutputFiles
import utils

CURRENT_DIR = Path(__file__).resolve().parent
logger = custom_logger.create_logger('NOVEL SCRAPPING')

@dataclass_json
@dataclass
class Metadata:
    novel_title : str
    author : str = "Anonymous"
    start_year: int = None
    end_year: int = None
    language: str = "en"

@dataclass_json
@dataclass
class Chapter:
    chapter_title: str
    chapter_link: str
    chapter_html_filename: str

    def __str__(self):
        return f'Title: {self.chapter_title}, link: {self.chapter_link}'

    def __lt__(self, another):
        return self.chapter_title < another.chapter_title

# class Volume:
#     def __init__(self, metadata: Metadata,
#                  volume_title: str = None,
#                  image_path: str = f'{CURRENT_DIR}/cover.jpg',
#                  single_volume: bool = False,
#                  autogenerated_title: bool = False):

#         self.metadata = metadata
#         self.volume_title = volume_title
#         self.chapters: list[Chapter] = []
#         self.image_path = image_path
#         self.single_volume = single_volume
#         self.autogenerated_title: bool = autogenerated_title

#     def create_chapter(self,
#                        chapter_title: str,
#                        content: str,
#                        chapter_link: str = None,
#                        html: bool = False):
#         if not chapter_idx:
#             chapter_idx = 1 if len(self.chapters) < 1 else len(self.chapters)

#         chapter = Chapter(chapter_title, content, chapter_link, html)
#         self.insert_chapter(chapter, chapter_idx)

#     def insert_chapter(self, new_chapter: Chapter, chapter_idx: int):
#         for chapter in self.chapters[chapter_idx:]:
#             chapter.chapter_idx += 1
#         self.chapters.insert(chapter_idx, new_chapter)

#     # Sort by volume_idx
#     def __lt__(self, another):
#         return self.volume_title < another.volume_title

@dataclass_json
@dataclass
class Novel:
    metadata: Metadata
    chapters: list[Chapter] = field(default_factory=list)
    toc_main_link: str = None
    toc_links_list: list[str] = field(default_factory=list)
    # toc: list[dict] = []
    # output_files: OutputFiles = None

    def __init__(self,
                 novel_title: str = None,
                 author: str = "Anonymous",
                 start_year: int = None,
                 end_year: int = None,
                 language: str = "en",
                 toc_main_link: str = None,
                 toc_links_list: list[str] = None,
                 metadata: Metadata = None,
                 chapters: list[Chapter] = None):

        if metadata is not None:
            self.metadata = metadata
        elif novel_title is not None:
            self.metadata = Metadata(novel_title,
                                    author=author,
                                    start_year=start_year,
                                    end_year=end_year,
                                    language=language)
        else:
            raise ValueError("You need to set 'novel_title' or 'metadata'.")

        self.chapters = chapters if chapters else []

        self.toc_main_link = toc_main_link
        self.toc_links_list = toc_links_list if toc_links_list else []

        self.toc = [{}]
        self.output_files = OutputFiles(self.metadata.novel_title)
        self.save_novel_to_json()
        self.decoder = Decoder(utils.obtain_host(self.toc_main_link))
        
    def save_novel_to_json(self):
        self.output_files.save_novel_json(self.to_dict())

    def add_chapter_toc(self,
                    chapter_link: str,
                    chapter_idx: int = None):
        print('test')

    def set_toc_main_link(self, toc_main_link: str):
        self.toc_main_link = toc_main_link
        self.update_chapter_list(update_toc=True)

    def update_chapter_list(self, update_toc: bool = False):
        toc_content, _ = utils.get_url_or_temp_file(self.output_files,
                                           self.toc_main_link,
                                           'toc_0.html',
                                           reload=update_toc)

        if not toc_content:
            logger.warning(f'No content found on link {self.toc_main_link}')
            return

        toc_links = [self.toc_main_link]
        if self.decoder.has_pagination():
            next_link_tag = self.decoder.decode_html(toc_content, 'next_page')
            aux = 1

            while next_link_tag:
                next_link = next_link_tag[0]['href']

                toc_new_content, _ = utils.get_url_or_temp_file(self.output_files,
                                                       next_link,
                                                       f'toc_{aux}.html',
                                                       reload=update_toc)
                if toc_new_content:
                    toc_links.append(next_link)
                    next_link_tag = self.decoder.decode_html(toc_new_content, 'next_page')
                aux += 1
        links = []
        for aux, link in enumerate(toc_links):
            toc_content, _ = utils.get_url_or_temp_file(self.output_files, link, f'toc_{aux}.html')
            toc_links = self.decoder.decode_html(toc_content, 'index')
            toc_links = [link['href'] for link in toc_links]
            if toc_links:
                links = [*links, *toc_links]
        self.toc_links_list = links
    
    def scrap_chapter(self, chapter_link: str, file_path: str = None, update_html: bool = False):
        chapter_content, chapter_html_filename = utils.get_url_or_temp_file(self.output_files,
                                               chapter_link,
                                               file_path,
                                               update_html)
        if chapter_content and chapter_html_filename:
            chapter_title = self.decoder.decode_html(chapter_content,
                                                     'title')
            if not chapter_title:
                logger.warning(f'No chapter title found for link: "{chapter_link}" on path: "{file_path}", using decoder: "title"')
                chapter_title = f'{self.metadata.novel_title} Chapter'

            chapter = Chapter(chapter_title=chapter_title,
                              chapter_link=chapter_link,
                              chapter_html_filename=chapter_html_filename)
            logger.info(f'Chapter scrapped from link: {chapter_link}')

            return chapter
        logger.warning(f'Failed to create chapter on link: "{chapter_link}" on path "{chapter_html_filename}"')
        
    def scrap_all_chapters(self, update_toc: bool = False, update_chapters: bool = False):
        self.update_chapter_list(update_toc)
        
        if self.toc_links_list:
            for link_idx, chapter_link in enumerate(self.toc_links_list):
                chapter = self.scrap_chapter(chapter_link,
                                             update_html=update_chapters)
                if chapter:
                    # Search if the chapter exists
                    chapter_idx = self.find_chapter_index_by_link(chapter_link)
                    if chapter_idx is not None:
                        # Replace the existing chapter
                        self.chapters[chapter_idx] = chapter
                        if chapter_idx != link_idx:
                            chapter_to_move = self.chapters.pop(chapter_idx)
                            self.chapters.insert(link_idx, chapter_to_move)
                    else:
                        # Add the new chapter
                        self.chapters.insert(link_idx, chapter)
                    self.save_novel_to_json()
        else:
            logger.warning('No links found on toc_links_list')
    
    def find_chapter_index_by_link(self, chapter_link: str):
        for index, chapter in enumerate(self.chapters):
            if chapter.chapter_link == chapter_link:
                return index
        return None
    # def to_dict(self):
    #     return {
    #         'metadata': asdict(self.metadata),
    #         # 'chapters': [asdict(chapter) for chapter in self.chapters],
    #         'toc_main_link': self.toc_main_link,
    #         'toc_links_list': self.toc_links_list,
    #         'toc': self.toc,
    #     }
        
    # def to_json(self):
    #     return json.dumps(self.to_dict(), ensure_ascii=False, indent=4)
    
    # def create_volume(self,
    #                   volume_idx: int = None,
    #                   volume_title: str = None,
    #                   image_path: str = None):
    #     if self.single_volume and volume_idx > 1:
    #         logger.error(f'Tried to create more than one volume for {self.metadata.novel_title}')
    #         return

    #     if not volume_idx:
    #         # If no index, use latest
    #         volume_idx = len(self.volumes)
    #     autogenerated_title = False
    #     if not volume_title:
    #         # Autogenerate Volume title:
    #         autogenerated_title = True
    #         if self.single_volume:
    #             volume_title = self.metadata.novel_title
    #         else:
    #             aux_idx = 1
    #             for volume in self.volumes[:volume_idx]:
    #                 if volume.autogenerated_title:
    #                     aux_idx += 1
    #             volume_title = f'{self.metadata.novel_title} {create_volume_id(aux_idx)}'

    #     volume = Volume(self.metadata, volume_title, image_path, self.single_volume, autogenerated_title)
    #     self.insert_volume(volume, volume_idx)

    # def insert_volume(self, new_volume: Volume, volume_idx: int):
    #     self.volumes.insert(volume_idx, new_volume)
